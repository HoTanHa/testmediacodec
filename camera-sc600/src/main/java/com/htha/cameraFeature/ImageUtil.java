package com.htha.cameraFeature;

import android.graphics.ImageFormat;
import android.graphics.Rect;
import android.graphics.YuvImage;
import android.media.Image;
import android.util.Log;

import java.io.ByteArrayOutputStream;
import java.nio.ByteBuffer;

public class ImageUtil {
    public static final int YUV420P = 0;
    public static final int YUV420SP = 1;
    public static final int NV21 = 2;
    private static final String TAG = "ImageUtil";

    /***
     * The comments in this method take 640*480 as an example
     * CropRect is not considered
     */
    public static byte[] getBytesFromImageAsType(Image image, int type) {
        try {
            //Get source data, if it is data in YUV format planes.length = 3
            //The actual data in plane[i] may exist byte[].length <= capacity (total buffer size)
            final Image.Plane[] planes = image.getPlanes();

            //The effective width of the data, generally, the picture width <= rowStride, which is also the cause of byte[].length <= capacity
            // So we only take the width part
            int width = image.getWidth();
            int height = image.getHeight();

            //This is used to fill the final YUV data, which requires 1.5 times the image size, because the YUV ratio is 4:1:1
            byte[] yuvBytes = new byte[width * height * ImageFormat.getBitsPerPixel(ImageFormat.YUV_420_888) / 8];
            //The position where the target array is filled
            int dstIndex = 0;

            //Temporarily store uv data
            byte uBytes[] = new byte[width * height / 4];
            byte vBytes[] = new byte[width * height / 4];
            int uIndex = 0;
            int vIndex = 0;

            int pixelsStride, rowStride;
            for (int i = 0; i < planes.length; i++) {
                pixelsStride = planes[i].getPixelStride();
                rowStride = planes[i].getRowStride();

                ByteBuffer buffer = planes[i].getBuffer();

                //If pixelsStride==2, the general Y buffer length=640*480, UV length=640*480/2-1
                //The index of the source data, the data of y is continuous in byte, the data of u is generated by shifting v to the left, and both are even-numbered bits as valid data
                byte[] bytes = new byte[buffer.capacity()];
                buffer.get(bytes);

                int srcIndex = 0;
                if (i == 0) {
                    //Take out all the effective area of ​​Y directly, or store it as a temporary bytes, and copy it to the next step
                    for (int j = 0; j < height; j++) {
                        System.arraycopy(bytes, srcIndex, yuvBytes, dstIndex, width);
                        srcIndex += rowStride;
                        dstIndex += width;
                    }
                }
                else if (i == 1) {
                    //Fetch the corresponding data according to pixelsStride
                    for (int j = 0; j < height / 2; j++) {
                        for (int k = 0; k < width / 2; k++) {
                            uBytes[uIndex++] = bytes[srcIndex];
                            srcIndex += pixelsStride;
                        }
                        if (pixelsStride == 2) {
                            srcIndex += rowStride - width;
                        }
                        else if (pixelsStride == 1) {
                            srcIndex += rowStride - width / 2;
                        }
                    }
                }
                else if (i == 2) {
                    //Fetch the corresponding data according to pixelsStride
                    for (int j = 0; j < height / 2; j++) {
                        for (int k = 0; k < width / 2; k++) {
                            vBytes[vIndex++] = bytes[srcIndex];
                            srcIndex += pixelsStride;
                        }
                        if (pixelsStride == 2) {
                            srcIndex += rowStride - width;
                        }
                        else if (pixelsStride == 1) {
                            srcIndex += rowStride - width / 2;
                        }
                    }
                }
            }

            image.close();

            //Fill in according to the required result type
            switch (type) {
                case YUV420P:
                    System.arraycopy(uBytes, 0, yuvBytes, dstIndex, uBytes.length);
                    System.arraycopy(vBytes, 0, yuvBytes, dstIndex + uBytes.length, vBytes.length);
                    break;
                case YUV420SP:
                    for (int i = 0; i < vBytes.length; i++) {
                        yuvBytes[dstIndex++] = uBytes[i];
                        yuvBytes[dstIndex++] = vBytes[i];
                    }
                    break;
                case NV21:
                    for (int i = 0; i < vBytes.length; i++) {
                        yuvBytes[dstIndex++] = vBytes[i];
                        yuvBytes[dstIndex++] = uBytes[i];
                    }
                    break;
            }
            return yuvBytes;
        }
        catch (final Exception e) {
            if (image != null) {
                image.close();
            }
            Log.i(TAG, e.toString());
        }
        return null;
    }

    public static byte[] NV21toYUV420Planar(byte[] input, byte[] output, int width, int height) {
        final int frameSize = width * height;
        final int qFrameSize = frameSize / 4;

        System.arraycopy(input, 0, output, 0, frameSize); // Y

        byte v, u;

        for (int i = 0; i < qFrameSize; i++) {
            v = input[frameSize + i * 2];
            u = input[frameSize + i * 2 + 1];

            output[frameSize + i + qFrameSize] = v;
            output[frameSize + i] = u;
        }

        return output;
    }

    public static byte[] YUV420PtoNV21(byte[] input, byte[] output, int width, int height) {
        final int frameSize = width * height;
        final int qFrameSize = frameSize / 4;

        System.arraycopy(input, 0, output, 0, frameSize); // Y

        byte v, u;

        for (int i = 0; i < qFrameSize; i++) {
            v = input[frameSize + i + qFrameSize];
            u = input[frameSize + i];
            output[frameSize + i * 2] = v;
            output[frameSize + i * 2 + 1] = u;
        }
        return output;
    }

    public static byte[] YUV420SPtoNV21(byte[] input, byte[] output, int width, int height) {
        final int frameSize = width * height;
        final int qFrameSize = frameSize / 4;

        System.arraycopy(input, 0, output, 0, frameSize); // Y

        byte v, u;

        for (int i = 0; i < qFrameSize * 2; i += 2) {
            output[frameSize + i + 1] = input[frameSize + i];
            output[frameSize + i] = input[frameSize + i + 1];
        }
        return output;
    }

//    private static byte[] tempBufferY = new byte[1280 * 720 * 2];
//    private static byte[] tempBufferU = new byte[1280 * 720];
//    private static byte[] tempBufferV = new byte[1280 * 720];

    public static byte[] imageGetByteYUV_420_888(Image image, byte[] output) {
        final Image.Plane[] planes = image.getPlanes();
        int width = image.getWidth();
        int height = image.getHeight();
        ByteBuffer yBuffer = planes[0].getBuffer();
        ByteBuffer uBuffer = planes[1].getBuffer();
        ByteBuffer vBuffer = planes[2].getBuffer();
        byte[] tempBufferY = new byte[yBuffer.remaining()];
        byte[] tempBufferU = new byte[uBuffer.remaining()];
        byte[] tempBufferV = new byte[vBuffer.remaining()];
        yBuffer.get(tempBufferY);
        uBuffer.get(tempBufferU);
        vBuffer.get(tempBufferV);
        int pixelsStrideU = planes[1].getPixelStride();
        int rowStrideU = planes[1].getRowStride();
        int pixelsStrideV = planes[2].getPixelStride();
        int rowStrideV = planes[2].getRowStride();

        int ySize = yBuffer.capacity();
        int uSize = uBuffer.capacity();
        int vSize = vBuffer.capacity();

        int srcIndexY = 0;
        int srcIndexU = 0;
        int srcIndexV = 0;
        int dstIndex = 0;
        int y = width * height;
        int dstIndexU = y;
        int dstIndexV = dstIndexU + 1;
        for (int j = 0; j < height; j++) {
            System.arraycopy(tempBufferY, srcIndexY, output, dstIndex, width);
            srcIndexY += rowStrideU;
            dstIndex += width;

            if (j % 2 == 0) {
                for (int k = 0; k < width / 2; k++) {
                    output[dstIndexU] = tempBufferU[srcIndexU];
                    srcIndexU += pixelsStrideU;
                    dstIndexU += 2;
                }
                if (pixelsStrideU == 2) {
                    srcIndexU += rowStrideU - width;
                }
                else if (pixelsStrideU == 1) {
                    srcIndexU += rowStrideU - width / 2;
                }
            }
            else {
                for (int k = 0; k < width / 2; k++) {
                    output[dstIndexV] = tempBufferV[srcIndexV];
                    srcIndexV += pixelsStrideV;
                    dstIndexV += 2;
                }
                if (pixelsStrideV == 2) {
                    srcIndexV += rowStrideV - width;
                }
                else if (pixelsStrideV == 1) {
                    srcIndexV += rowStrideV - width / 2;
                }
            }
        }

//        yBuffer.get(output, 0, ySize);
//        uBuffer.get(output, ySize, uSize);
//        vBuffer.get(output, ySize + uSize, vSize);

        return output;
    }

    public static byte[] NV21toJPEG(byte[] nv21, int width, int height, int quality) {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        YuvImage yuv = new YuvImage(nv21, ImageFormat.NV21, width, height, null);
        yuv.compressToJpeg(new Rect(0, 0, width, height), quality, out);
        return out.toByteArray();
    }
}
